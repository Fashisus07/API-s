{"ast":null,"code":"// Importar datos de usuarios desde archivo JSON local\nimport usersData from '../data/users.json';\n\n// Clase para manejar autenticación de usuarios (simulación de backend)\nclass AuthService {\n  constructor() {\n    // Inicializar lista de usuarios con datos del JSON\n    this.users = [...usersData.users];\n    // Cargar usuarios adicionales desde localStorage si existen\n    this.loadUsersFromStorage();\n  }\n\n  // Cargar usuarios del localStorage si existen (para persistir registros nuevos)\n  loadUsersFromStorage() {\n    // Obtener usuarios guardados en localStorage\n    const storedUsers = localStorage.getItem('ecommerce_users');\n    // Si existen usuarios guardados, reemplazar la lista actual\n    if (storedUsers) {\n      this.users = JSON.parse(storedUsers);\n    }\n  }\n\n  // Guardar usuarios en localStorage para persistencia\n  saveUsersToStorage() {\n    // Convertir lista de usuarios a JSON y guardar en localStorage\n    localStorage.setItem('ecommerce_users', JSON.stringify(this.users));\n  }\n\n  // Simular proceso de login con validación de credenciales\n  async login(email, password) {\n    // Retornar una promesa para simular petición asíncrona\n    return new Promise((resolve, reject) => {\n      // Simular delay de red con setTimeout\n      setTimeout(() => {\n        // Buscar usuario que coincida con email, password y esté activo\n        const user = this.users.find(u => u.email === email && u.password === password && u.isActive);\n\n        // Si se encuentra el usuario, generar respuesta exitosa\n        if (user) {\n          // Generar token JWT simulado\n          const token = this.generateToken(user);\n          // Crear objeto de respuesta con datos del usuario\n          const userResponse = {\n            token,\n            name: user.firstName,\n            surname: user.lastName,\n            email: user.email,\n            username: user.username,\n            role: user.role,\n            id: user.id\n          };\n          // Resolver promesa con datos del usuario\n          resolve({\n            data: userResponse\n          });\n        } else {\n          // Si no se encuentra, rechazar con error de credenciales\n          reject({\n            response: {\n              data: {\n                error: 'Credenciales incorrectas'\n              }\n            }\n          });\n        }\n      }, 500); // Simular delay de red de 500ms\n    });\n  }\n\n  // Simular proceso de registro de nuevos usuarios\n  async register(userData) {\n    // Retornar promesa para simular petición asíncrona\n    return new Promise((resolve, reject) => {\n      // Simular delay de red con setTimeout\n      setTimeout(() => {\n        // Verificar si el email ya existe en la base de datos\n        const existingUser = this.users.find(u => u.email === userData.email);\n        if (existingUser) {\n          // Si el email ya existe, rechazar con error\n          reject({\n            response: {\n              data: {\n                error: 'El email ya está registrado'\n              }\n            }\n          });\n          return;\n        }\n\n        // Crear nuevo objeto usuario con datos proporcionados\n        const newUser = {\n          id: this.getNextId(),\n          // Generar ID único\n          username: userData.email.split('@')[0],\n          // Usar parte del email como username\n          email: userData.email,\n          password: userData.password,\n          firstName: userData.name,\n          lastName: userData.surname,\n          dni: userData.dni,\n          role: 'user',\n          // Rol por defecto para nuevos usuarios\n          createdAt: new Date().toISOString(),\n          // Fecha de creación\n          isActive: true // Usuario activo por defecto\n        };\n\n        // Agregar nuevo usuario a la lista\n        this.users.push(newUser);\n        // Guardar lista actualizada en localStorage\n        this.saveUsersToStorage();\n\n        // Generar token JWT para el nuevo usuario\n        const token = this.generateToken(newUser);\n        // Crear objeto de respuesta con datos del usuario registrado\n        const userResponse = {\n          token,\n          name: newUser.firstName,\n          surname: newUser.lastName,\n          email: newUser.email,\n          username: newUser.username,\n          dni: newUser.dni,\n          role: newUser.role,\n          id: newUser.id\n        };\n\n        // Resolver promesa con datos del usuario registrado\n        resolve({\n          data: userResponse\n        });\n      }, 800); // Simular delay de red de 800ms\n    });\n  }\n\n  // Generar token JWT simple (en producción usar librería JWT real)\n  generateToken(user) {\n    // Crear payload con información del usuario y expiración\n    const payload = {\n      id: user.id,\n      email: user.email,\n      role: user.role,\n      exp: Date.now() + 24 * 60 * 60 * 1000 // Expira en 24 horas\n    };\n    // Convertir payload a JSON string\n    const jsonString = JSON.stringify(payload);\n    // Codificar a base64 de forma segura para caracteres especiales\n    return btoa(unescape(encodeURIComponent(jsonString)));\n  }\n\n  // Verificar validez y decodificar token JWT\n  verifyToken(token) {\n    try {\n      // Decodificar token desde base64\n      const decodedString = decodeURIComponent(escape(atob(token)));\n      // Parsear JSON del payload\n      const payload = JSON.parse(decodedString);\n      // Verificar si el token ha expirado\n      if (payload.exp < Date.now()) {\n        return null; // Token expirado\n      }\n      // Retornar payload si el token es válido\n      return payload;\n    } catch (error) {\n      // Si hay error en decodificación, token es inválido\n      return null; // Token inválido\n    }\n  }\n\n  // Obtener siguiente ID disponible para nuevos usuarios\n  getNextId() {\n    // Encontrar el ID más alto en la lista de usuarios\n    const maxId = Math.max(...this.users.map(u => u.id), 0);\n    // Retornar el siguiente ID disponible\n    return maxId + 1;\n  }\n\n  // Obtener todos los usuarios activos (para funciones de administrador)\n  getAllUsers() {\n    // Filtrar solo usuarios activos\n    return this.users.filter(u => u.isActive);\n  }\n\n  // Buscar usuario específico por ID\n  getUserById(id) {\n    // Encontrar usuario por ID que esté activo\n    return this.users.find(u => u.id === id && u.isActive);\n  }\n}\n\n// Exportar instancia única del servicio de autenticación (patrón Singleton)\nexport default new AuthService();","map":{"version":3,"names":["usersData","AuthService","constructor","users","loadUsersFromStorage","storedUsers","localStorage","getItem","JSON","parse","saveUsersToStorage","setItem","stringify","login","email","password","Promise","resolve","reject","setTimeout","user","find","u","isActive","token","generateToken","userResponse","name","firstName","surname","lastName","username","role","id","data","response","error","register","userData","existingUser","newUser","getNextId","split","dni","createdAt","Date","toISOString","push","payload","exp","now","jsonString","btoa","unescape","encodeURIComponent","verifyToken","decodedString","decodeURIComponent","escape","atob","maxId","Math","max","map","getAllUsers","filter","getUserById"],"sources":["C:/Users/sebal/Desktop/API v3/API-s-main/frontend/src/services/authService.js"],"sourcesContent":["// Importar datos de usuarios desde archivo JSON local\nimport usersData from '../data/users.json';\n\n// Clase para manejar autenticación de usuarios (simulación de backend)\nclass AuthService {\n  constructor() {\n    // Inicializar lista de usuarios con datos del JSON\n    this.users = [...usersData.users];\n    // Cargar usuarios adicionales desde localStorage si existen\n    this.loadUsersFromStorage();\n  }\n\n  // Cargar usuarios del localStorage si existen (para persistir registros nuevos)\n  loadUsersFromStorage() {\n    // Obtener usuarios guardados en localStorage\n    const storedUsers = localStorage.getItem('ecommerce_users');\n    // Si existen usuarios guardados, reemplazar la lista actual\n    if (storedUsers) {\n      this.users = JSON.parse(storedUsers);\n    }\n  }\n\n  // Guardar usuarios en localStorage para persistencia\n  saveUsersToStorage() {\n    // Convertir lista de usuarios a JSON y guardar en localStorage\n    localStorage.setItem('ecommerce_users', JSON.stringify(this.users));\n  }\n\n  // Simular proceso de login con validación de credenciales\n  async login(email, password) {\n    // Retornar una promesa para simular petición asíncrona\n    return new Promise((resolve, reject) => {\n      // Simular delay de red con setTimeout\n      setTimeout(() => {\n        // Buscar usuario que coincida con email, password y esté activo\n        const user = this.users.find(u =>\n          u.email === email && u.password === password && u.isActive\n        );\n\n        // Si se encuentra el usuario, generar respuesta exitosa\n        if (user) {\n          // Generar token JWT simulado\n          const token = this.generateToken(user);\n          // Crear objeto de respuesta con datos del usuario\n          const userResponse = {\n            token,\n            name: user.firstName,\n            surname: user.lastName,\n            email: user.email,\n            username: user.username,\n            role: user.role,\n            id: user.id\n          };\n          // Resolver promesa con datos del usuario\n          resolve({ data: userResponse });\n        } else {\n          // Si no se encuentra, rechazar con error de credenciales\n          reject({\n            response: {\n              data: {\n                error: 'Credenciales incorrectas'\n              }\n            }\n          });\n        }\n      }, 500); // Simular delay de red de 500ms\n    });\n  }\n\n  // Simular proceso de registro de nuevos usuarios\n  async register(userData) {\n    // Retornar promesa para simular petición asíncrona\n    return new Promise((resolve, reject) => {\n      // Simular delay de red con setTimeout\n      setTimeout(() => {\n        // Verificar si el email ya existe en la base de datos\n        const existingUser = this.users.find(u => u.email === userData.email);\n        if (existingUser) {\n          // Si el email ya existe, rechazar con error\n          reject({\n            response: {\n              data: {\n                error: 'El email ya está registrado'\n              }\n            }\n          });\n          return;\n        }\n\n        // Crear nuevo objeto usuario con datos proporcionados\n        const newUser = {\n          id: this.getNextId(), // Generar ID único\n          username: userData.email.split('@')[0], // Usar parte del email como username\n          email: userData.email,\n          password: userData.password,\n          firstName: userData.name,\n          lastName: userData.surname,\n          dni: userData.dni,\n          role: 'user', // Rol por defecto para nuevos usuarios\n          createdAt: new Date().toISOString(), // Fecha de creación\n          isActive: true // Usuario activo por defecto\n        };\n\n        // Agregar nuevo usuario a la lista\n        this.users.push(newUser);\n        // Guardar lista actualizada en localStorage\n        this.saveUsersToStorage();\n\n        // Generar token JWT para el nuevo usuario\n        const token = this.generateToken(newUser);\n        // Crear objeto de respuesta con datos del usuario registrado\n        const userResponse = {\n          token,\n          name: newUser.firstName,\n          surname: newUser.lastName,\n          email: newUser.email,\n          username: newUser.username,\n          dni: newUser.dni,\n          role: newUser.role,\n          id: newUser.id\n        };\n\n        // Resolver promesa con datos del usuario registrado\n        resolve({ data: userResponse });\n      }, 800); // Simular delay de red de 800ms\n    });\n  }\n\n  // Generar token JWT simple (en producción usar librería JWT real)\n  generateToken(user) {\n    // Crear payload con información del usuario y expiración\n    const payload = {\n      id: user.id,\n      email: user.email,\n      role: user.role,\n      exp: Date.now() + (24 * 60 * 60 * 1000) // Expira en 24 horas\n    };\n    // Convertir payload a JSON string\n    const jsonString = JSON.stringify(payload);\n    // Codificar a base64 de forma segura para caracteres especiales\n    return btoa(unescape(encodeURIComponent(jsonString)));\n  }\n\n  // Verificar validez y decodificar token JWT\n  verifyToken(token) {\n    try {\n      // Decodificar token desde base64\n      const decodedString = decodeURIComponent(escape(atob(token)));\n      // Parsear JSON del payload\n      const payload = JSON.parse(decodedString);\n      // Verificar si el token ha expirado\n      if (payload.exp < Date.now()) {\n        return null; // Token expirado\n      }\n      // Retornar payload si el token es válido\n      return payload;\n    } catch (error) {\n      // Si hay error en decodificación, token es inválido\n      return null; // Token inválido\n    }\n  }\n\n  // Obtener siguiente ID disponible para nuevos usuarios\n  getNextId() {\n    // Encontrar el ID más alto en la lista de usuarios\n    const maxId = Math.max(...this.users.map(u => u.id), 0);\n    // Retornar el siguiente ID disponible\n    return maxId + 1;\n  }\n\n  // Obtener todos los usuarios activos (para funciones de administrador)\n  getAllUsers() {\n    // Filtrar solo usuarios activos\n    return this.users.filter(u => u.isActive);\n  }\n\n  // Buscar usuario específico por ID\n  getUserById(id) {\n    // Encontrar usuario por ID que esté activo\n    return this.users.find(u => u.id === id && u.isActive);\n  }\n}\n\n// Exportar instancia única del servicio de autenticación (patrón Singleton)\nexport default new AuthService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}